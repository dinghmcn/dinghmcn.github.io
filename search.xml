<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[ExceptionInThreadMain]]></title>
    <url>%2F2018%2F01%2F24%2FExceptionInThreadMain%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。作为一个Java程序员，在运行Java程序时，你肯定看到过 =exception in thread main=。如果你使用Java IDE例如Eclipse或者Netbeans来运行Java程序，你可能不会面对这些问题，因为IDE在运行前会做语法检查并在语法不正确时无法运行。 在这里，我解释了一些常见Java程序异常，当你从终端运行Java程序时会看到这些主线程异常。Exception in thread main java.lang.UnsupportedClassVersionError当你的Java类是从一个JDK版本编译后，这个异常是在你试图从另一个Java版本运行时发生的。12345678package com.journaldev.util; public class ExceptionInMain { public static void main() { System.out.println(10); } } 当我在Eclipse创建这个项目，并保持JRE版本为Java7，类编译出来的Java版本是1.7；但是在终端中Java版本是1.6，当尝试在终端中运行这个类，报出以下异常信息。 pankaj@Pankaj:~/Java7Features/bin$java com/journaldev/util/ExceptionInMain Exception in thread "main" java.lang.UnsupportedClassVersionError: com/journaldev/util/ExceptionInMain : Unsupported major.minor version 51.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631) at java.lang.ClassLoader.defineClass(ClassLoader.java:615) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141) at java.net.URLClassLoader.defineClass(URLClassLoader.java:283) at java.net.URLClassLoader.access$000(URLClassLoader.java:58) at java.net.URLClassLoader$1.run(URLClassLoader.java:197) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:190) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:247)pankaj@Pankaj:~/Java7Features/bin$java com/journaldev/util/ExceptionInMain Exception in thread "main" java.lang.UnsupportedClassVersionError: com/journaldev/util/ExceptionInMain : Unsupported major.minor version 51.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631) at java.lang.ClassLoader.defineClass(ClassLoader.java:615) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141) at java.net.URLClassLoader.defineClass(URLClassLoader.java:283) at java.net.URLClassLoader.access$000(URLClassLoader.java:58) at java.net.URLClassLoader$1.run(URLClassLoader.java:197) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:190) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:247) 我们不能在高版本Java环境下编译Java源文件而在低版本上运行。Exception in thread main java.lang.NoClassDefFoundError这个异常有两种情况，第一种：运行Java程序是只需指定类名而不用加文件后缀。当增加.class后缀将抛出无法找到该类的异常 NoClassDefFoundError 。pankaj@Pankaj:~/CODE/Java7Features/bin$java com/journaldev/util/ExceptionInMain.class Exception in thread "main" java.lang.NoClassDefFoundError: com/journaldev/util/ExceptionInMain/class Caused by: java.lang.ClassNotFoundException: com.journaldev.util.ExceptionInMain.class at java.net.URLClassLoader$1.run(URLClassLoader.java:202) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:190) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:247)当没有找到类的第二种情形。pankaj@Pankajs-MacBook-Pro:~/CODE/Java7Features/bin/com/journaldev/util$java ExceptionInMain Exception in thread "main" java.lang.NoClassDefFoundError: ExceptionInMain (wrong name: com/journaldev/util/ExceptionInMain) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:791) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:449) at java.net.URLClassLoader.access$100(URLClassLoader.java:71) at java.net.URLClassLoader$1.run(URLClassLoader.java:361) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:423) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:356) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:480)Exception in thread main java.lang.NoSuchMethodError: main当你试图运行一个没有 main() 方法的类时，在Java7中抛出以下异常信息。pankaj@Pankaj:~/CODE/Java7Features/bin$ java com/journaldev/util/ExceptionInMain Error: Main method not found in class com.journaldev.util.ExceptionInMain, please define the main method as: public static void main(String[] args)Exception in thread “main” java.lang.ArithmeticException每当主线程中的 main() 方法抛出异常时，它将打印出控制台的异常信息。第一部分说明了从 main() 方法抛出了异常，第二部分打印出异常类名，冒号后面就是异常信息。 例如，我们把输出语句改为 System.out.println(10/0); ,它将抛出 ArithmeticException 异常。Exception in thread "main" java.lang.ArithmeticException: / by zero at com.journaldev.util.ExceptionInMain.main(ExceptionInMain.java:6)修复主线程异常的一些方法是否编译和运行的Java版本相同；是否从类所在的目录及包名目录运行Java类；Java类及依赖类路径是否设置正确；运行Java程序时是否只使用类名；是否正确的 main() 方法.你注意到没有以上所有异常都是主线程抛出的，因为 main() 方法是Java程序的第一个线程。]]></content>
      <categories>
        <category>Java Threa</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread Safety In Java Singleton Classes]]></title>
    <url>%2F2018%2F01%2F24%2FThreadSafetyInJavaSingletonClasses%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。单例模式是使用最广泛的限制对象创建的设计模式之一；在实际实现中，像数据库连接或企业信息系统（EIS）这些有限的资源，应合理使用避免资源紧缺。我们可以使用单例模式实现这一目的，为资源创建包装类，并限制运行时最多只能创建一个对象。创建单例类一般来说，我们可以按照以下步骤创建一个单例类：重写私有构造函数，禁止通过 new 操作符创建新对象；声明一个当前类的私有静态实例；提供一个公共的静态方法，它将返回上一步声明的实例变量，如果该变量没有初始化，使用第1步重写的构造函数进行初始化，否则直接返回该实例变量。ASingleton.java12345678910111213141516package com.journaldev.designpatterns; public class ASingleton { private static ASingleton instance = null; private ASingleton() { } public static ASingleton getInstance() { if (instance == null) { instance = new ASingleton(); } return instance; } } 上面代码中， getInstance() 方法不是线程安全的。多个线程可以同时访问它，对于初始化实例变量的前几个线程都可以进入if语句块内创建多个实例并破坏单例实现。我们有三种方法实现线程安全的。在类加载时初始化实例变量。优点：不使用同步就能实现线程安全；容易实现；缺点：过早的创建了并不会使用的资源；程序不能向其传递任何参数，所以重用它；使该 getInstance() 方法是同步的优点：能够保证线程安全；可以传递参数；惰性初始化；缺点：由于锁开销，性能会下降；一旦实例被初始化，同步就是多余的；对 volatile 变量和if语句中使用同步块优点：能够保证线程安全；可以传递参数；惰性初始化；同步开销最小，只会限制变量为空的前几个线程；缺点：额外的条件；满足条件的情况下，3无疑是最好的，修改的实例如下：12345678910111213141516171819202122package com.journaldev.designpatterns; public class ASingleton { private static volatile ASingleton instance; private static Object mutex = new Object(); private ASingleton() { } public static ASingleton getInstance() { ASingleton result = instance; if (result == null) { synchronized (mutex) { result = instance; if (result == null) instance = result = new ASingleton(); } } return result; } } 局部变量 result 似乎没有必要，但能提供代码性能。在实例已被初始化的情况下（绝大部分时间）， volatile 字段只被访问一次（ return result 而不是 return instance ），这可以将方法的整体性能提高大约25%。]]></content>
      <categories>
        <category>Java Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread Safety In Java]]></title>
    <url>%2F2018%2F01%2F23%2FThreadSafetyInJava%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。线程安全对于Java来说是一个非常重要的课题。Java支持并发编程，当多个线程访问相同的 Object 对象的共享变量时会导致数据不一致。 导致数据不一致的原因是：被访问的字段值不是原子进程，我们应该首先读取当前值，然后执行必要的操作以后去更新的值，第三步将更新的值分配给字段的引用。 我们用一个简单的程序要验证这个问题，其中多个线程正在更新共享数据。12345678910111213141516171819202122232425262728293031323334353637383940414243package com.journaldev.threads; public class ThreadSafety { public static void main(String[] args) throws InterruptedException { ProcessingThread pt = new ProcessingThread(); Thread t1 = new Thread(pt, "t1"); t1.start(); Thread t2 = new Thread(pt, "t2"); t2.start(); //wait for threads to finish processing t1.join(); t2.join(); System.out.println("Processing count="+pt.getCount()); } } class ProcessingThread implements Runnable{ private int count; @Override public void run() { for(int i=1; i &lt; 5; i++){ processSomething(i); count++; } } public int getCount() { return this.count; } private void processSomething(int i) { // processing some job try { Thread.sleep(i*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } 上面程序运行预期的结果： count 的值应该是8，但我们都次运行发现实际输出为6、7、8的任意值。这是因为 count++ 不是一个原子操作导致了数据损坏。实现线程安全的方式Java中的线程安全是使程序安全地在多线程环境中实用的过程没，我们可以通过不同的方式使程序是线程安全的。同步是Java中最简单和最广泛使用的线程安全工具；使用 java.util.concurrent.atomic 包中的原子包装类，例如 =AtomicInteger=；使用 java.util.concurrent.locks 包中的各种锁；使用线程安全的集合类，例如： =ConcurrentHashMap=；对变量使用 volatile 关键字强制每个线程从内存中读取数据，而不是从线程缓存中读取。Java同步同步是一种可以使线程安全的工具，Java虚拟机保证同步块同一时间最多只能被一个线程执行，Java关键字 synchronized 用于创建同步代码，并在内部使用类对象或类上的锁确保最多只有一个线程执行同步块。Java同步的工作方式：锁定、释放资源；在任何线程进入同步代码之前，必须获取对象锁并在结束时释放；当它释放资源后其他线程在可以获取。同时其它线程处于等待状态来锁定同步资源。我们可以通过两种方式使用 synchronized 关键字，创建同步方法和创建同步代码块。当一个方法是同步的，它锁定对象，如果方法是静态的则锁定类；因此最好使用同步代码块来锁定方法需要同步的部分代码。在创建同步代码块的同时，我们需要指定被获取锁的资源，它可以使 XYz.class 或 类的任意对象字段。synchronized(this) 将在进入同步块之前锁定对象。你应该使用最低级别的锁定。例如，如果一个类中有多个同步块，并且其中一个锁定了对象，则其他同步块也将被锁定且不能被其他线程执行。当我们锁定一个对象时，它同时获取对象所有字段的锁。Java同步提供的数据完整性会牺牲性能，因此只有在十分必要的情况下使用它。Java同步只能在同一Java虚拟机下生效，因此如果你要在多虚拟机下锁定一些资源，它将不会起作用，你可能需要查看一下全局锁机制。Java同步可能会导致死锁。synchronized 关键字不能用于构造函数和变量。最好创建一个用于同步块的虚拟私有对象，因为它的引用不会被其他代码改变。不应该使用在常量池中维护的任何对象。例如，字符串不应用于同步，如果其他代码锁定相同的字符串，它会尝试从字符串池中获取同一个引用对象上的锁，即两个不相关的代码互相锁定了。实例这里我们修改上面的程序，以使其线程安全。1234567//dummy object variable for synchronization private Object mutex=new Object(); ... //using synchronized block to read, increment and update count value synchronously synchronized (mutex) { count++; } 同步代码块和同步方法12345678910111213141516public class MyObject { // Locks on the object's monitor public synchronized void doSomething() { // ... } } // Hackers code MyObject myObject = new MyObject(); synchronized (myObject) { while (true) { // Indefinitely delay myObject Thread.sleep(Integer.MAX_VALUE); } } 这是Java中关于线程安全和使用 synchronized 关键字的相关知识。]]></content>
      <categories>
        <category>Java Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread Wait And Notify]]></title>
    <url>%2F2018%2F01%2F23%2FThreadWaitAndNotify%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。Java的 Object 类包含三个 final 方法允许线程与锁定状态的资源通信。它们是： wait() ， notify() ，和 notifyAll() 。线程在任何对象上调用这些方法必须持有该对象的监听器否则会抛出 java.lang.IllegalMonitorStateException 异常。waitObject 的 wait() 方法有三种重载形式。一种是无限等待在该对象上直到其他线程调用 notify() 或 notifyAll() 方法来唤醒它 ；另外两种会使线程在唤醒前等待指定的时间。notifynotify() 方法唤醒一个等待在该对象上的线程且该线程开始执行。如果有多个线程等待在该对象上，该方法只会唤醒其中一个。具体是哪一个取决于线程管理程序的系统实现。notifynotify() 方法唤醒等待在该对象上的所有线程，但是那个线程先执行取决于具体系统的实现。实例我们来看一个例子，其中多个线程工作在同一个对象上，我们使用 wait() 、 notify() 和 notifyAll() 方法。Message 一个简单的Java类，线程将在其上工作并调用 wait() 、 notify() 和 notifyAll() 方法。123456789101112131415161718package com.journaldev.concurrency; public class Message { private String msg; public Message(String str){ this.msg=str; } public String getMsg() { return msg; } public void setMsg(String str) { this.msg=str; } } Waiter 这个类将等待其他线程调用通知方法来唤醒并执行。它使用同步块持有Message对象的监听器。123456789101112131415161718192021222324252627package com.journaldev.concurrency; public class Waiter implements Runnable{ private Message msg; public Waiter(Message m){ this.msg=m; } @Override public void run() { String name = Thread.currentThread().getName(); synchronized (msg) { try{ System.out.println(name+" waiting to get notified at time:"+System.currentTimeMillis()); msg.wait(); }catch(InterruptedException e){ e.printStackTrace(); } System.out.println(name+" waiter thread got notified at time:"+System.currentTimeMillis()); //process the message now System.out.println(name+" processed: "+msg.getMsg()); } } } Notifer 一个运行在Message对象上的类，调用 notify() 方法来唤醒等待在Massage对象上的线程。请注意，使用同步块持有Message对象的监听器。1234567891011121314151617181920212223242526package com.journaldev.concurrency; public class Notifier implements Runnable { private Message msg; public Notifier(Message msg) { this.msg = msg; } @Override public void run() { String name = Thread.currentThread().getName(); System.out.println(name+" started"); try { Thread.sleep(1000); synchronized (msg) { msg.setMsg(name+" Notifier work done"); msg.notify(); // msg.notifyAll(); } } catch (InterruptedException e) { e.printStackTrace(); } } } WaitNotifyTest 测试类将创建Waiter和Notifier的多线程并启动他们。1234567891011121314151617package com.journaldev.concurrency; public class WaitNotifyTest { public static void main(String[] args) { Message msg = new Message("process it"); Waiter waiter = new Waiter(msg); new Thread(waiter,"waiter").start(); Waiter waiter1 = new Waiter(msg); new Thread(waiter1, "waiter1").start(); Notifier notifier = new Notifier(msg); new Thread(notifier, "notifier").start(); System.out.println("All the threads are started"); } } 测试结果当我们运行上面的程序时，我们会看到下面的输出，但是程序不会完成，因为有两个线程在等待Message对象，而 notify() 方法只会唤醒其中一个，另一个还在等待唤醒。 waiter waiting to get notified at time:1356318734009 waiter1 waiting to get notified at time:1356318734010 All the threads are started notifier started waiter waiter thread got notified at time:1356318735011 waiter processed: notifier Notifier work done 如果我们注释掉 msg.notify() 并取消 // mag.notifyAll() 的注释再次运行，则显示： waiter waiting to get notified at time:1356318917118 waiter1 waiting to get notified at time:1356318917118 All the threads are started notifier started waiter1 waiter thread got notified at time:1356318918120 waiter1 processed: notifier Notifier work done waiter waiter thread got notified at time:1356318918120 waiter processed: notifier Notifier work done 由于 notifyAll() 方法唤醒所有Waiter线程并执行，完成后程序将终止。 以上就是Java的 wait() 、 notify() 和 notifyAll() 方法。]]></content>
      <categories>
        <category>Java Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread Life Cycle In Java]]></title>
    <url>%2F2018%2F01%2F22%2FThreadLifeCycleInJava%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。理解线程生命周期和各种状态对线程的使用和并发编程非常重要。我们可以通过实现 Runnable 接口或继承 Thread 类来创建一个Java线程类，但是启动它必须要先创建它的对象并调用 start() 方法执行 run() 方法来作为线程。Java线程的生命周期下图显示了Java线程生命周期的不同状态，首先创建一个线程并启动它，但是线程怎样由 可运行状态 到 运行状态 再到 阻塞状态 依赖于调度程序的系统实现并不完全受Java程序控制。创建当我们使用 new 操作符创建线程对象，线程状态是 新线程 。这个状态下线程不是活动的，它处于Java程序的一个内部状态。可运行当线程对象调用 start() 方法，切换到 =可运行状态=。控制权移交到线程调度程序去完成线程的执行。该线程是立即运行还是保存到可运行线程池中这取决于线程调度程序系统的实现。运行当线程执行时，它的状态切换到 运行状态 。线程调度程序从可运行线程池中选取一个线程并把它的状态切换为 运行状态 ，然后CPU执行该线程。线程由 可运行状态 切换到 可运行状态 、 死亡状态 或 阻塞状态 取决于时间片、是否执行完 run() 方法和是否需要等待资源。阻塞线程可能需要等待其它调用 Thread.join 方法的线程结束或需要等待一些资源。例如需要等待IO资源时则它的状态切换为 等待状态 。线程等待结束后，状态变为 可执行状态 ，并从可执行线程池中移除。死亡一旦线程执行完成，他的状态切换为 死亡状态 ，他被认为是非活跃的。以上是线程的不同状态，理解它们以及线程状态是如何改变是很重要的，这就是线程的生命周期。]]></content>
      <categories>
        <category>Java Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread Join]]></title>
    <url>%2F2018%2F01%2F19%2FJavaThreadJoin%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。Java Thread.join= 方法可以暂停当前线程的执行，直到指定的线程死亡。它有三个重载方法。Java Thread joinpublic final void join() 暂停当前线程直到调用该方法的线程死亡。public final synchronized void join(long millis) 暂停当前线程直到调用该方法的线程死亡或指定时间（millis）。由于线程的执行依赖于OS实现不能保证当前线程只等待指定的时长。public final synchronized void join(long millis, int nanos) 指定时间可以定义毫秒+纳秒。下面是一个 join 方法的简单实例，程序的目的是保证主线程是最后一个执行完成，第三个线程在第一个线程死亡后才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.journaldev.threads; public class ThreadJoinExample { public static void main(String[] args) { Thread t1 = new Thread(new MyRunnable(), "t1"); Thread t2 = new Thread(new MyRunnable(), "t2"); Thread t3 = new Thread(new MyRunnable(), "t3"); t1.start(); //start second thread after waiting for 2 seconds or if it's dead try { t1.join(2000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); //start third thread only when first thread is dead try { t1.join(); } catch (InterruptedException e) { e.printStackTrace(); } t3.start(); //let all threads finish execution before finishing main thread try { t1.join(); t2.join(); t3.join(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println("All threads are dead, exiting main thread"); } } class MyRunnable implements Runnable{ @Override public void run() { System.out.println("Thread started:::"+Thread.currentThread().getName()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Thread ended:::"+Thread.currentThread().getName()); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java Thread Sleep]]></title>
    <url>%2F2018%2F01%2F18%2FJavaThreadSleep%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。Java中的 Thread.sleep可以用 Thread.sleep(long millis) 方法暂停当前线程的执行，以毫秒为单位指定时间。还有一种重载方法 Thread.sleep(long millis, int nanos) 可以以毫秒和纳秒指定时间，纳秒取值范围为：0 &lt;= nanos &lt;= 999999.Java线程睡眠实例这是一个简单的程序，其中Thread.sleep() 用于使主线程睡眠2s。1234567891011package com.journaldev.threads; public class ThreadSleep { public static void main(String[] args) throws InterruptedException { long start = System.currentTimeMillis(); Thread.sleep(2000); System.out.println("Sleep time in ms = "+(System.currentTimeMillis()-start)); } } 如果你运行上面的程序，你会发现打印的睡眠时间会略大于2000ms。这是由线程调度程序的线程睡眠工作方式和特定于操作系统的实现导致的。Java线程睡眠重点它总是暂停当前线程的执行；实际睡眠时间（从睡眠到重新开始执行）取决于系统定时器和调度程序，对于一个空闲的系统来说接近指定的时间，但是对于一个繁忙的系统来说会比指定的时间长；线程睡眠不会丢失任何已经获取的监听器和锁；任何其它线程可以中断当前正在睡眠的线程，但是会抛出 InterruptedException 异常。Java线程睡眠工作原理Thread.sleep() 与线程调度进行交互，使当前线程在指定的时间内处于等待状态。等待时间结束后，线程状态变为可运行状态等待CPU执行。所以当前线程的时间睡眠时间取决于操作系统的线程调度程序。]]></content>
      <categories>
        <category>Java Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread Example]]></title>
    <url>%2F2018%2F01%2F17%2FJavaThreadExample%2F</url>
    <content type="text"><![CDATA[翻译的不是很好，英文好的可以直接看原文。欢迎来到Java线程实例。进程和线程是执行的两个基本单位。并发编程更在意Java线程。进程进程拥有自己独立的执行环境，可以把它看作一个程序或应用。但是一个程序可以包含多个进程。Java运行环境作为一个单独的程序而运行，其中包含不同的类和程序的进程。线程线程可以看作轻量级的进程。线程创建于其所属进程中，只需较少资源但与其进程共享资源。Java线程实例每一个Java应用至少拥有一个线程——主线程。 尽管有很多其它后台线程（内存管理、系统管理、信号处理等）。但是从应用程序的角度来看，主线程是第一个创建的Java线程，我们可以从中创建多个线程。 多线程是指在一个进程中同时执行两个或两个以上的线程。计算机单核处理器一次只能执行一个线程，而时间分片能实现不同进程和线程之间共享处理器时间。Java线程的好处与进程相比线程是轻量级的，创建线程所需的时间和资源更少;线程共享其父线程数据和代码；线程间的上下文切换通常比进程的廉价；线程间通信通常比进程间通信容易。Java线程的两种创建方式实现Runnable接口 使一个类可以运行，我们可以实现 java.lang.Runnable 接口并重写 public void run() 方法，然后把它的对象传给Thread的构造函数创建Thread对象，执行Thread对象的 start() 方法即可执行该类的 run() 方法。123456789101112131415161718192021package com.journaldev.threads; public class HeavyWorkRunnable implements Runnable { @Override public void run() { System.out.println("Doing heavy processing - START "+Thread.currentThread().getName()); try { Thread.sleep(1000); //Get database connection, delete unused data from DB doDBProcessing(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Doing heavy processing - END "+Thread.currentThread().getName()); } private void doDBProcessing() throws InterruptedException { Thread.sleep(5000); } } 继承Thread类 我们可以继承 java.lang.Thread 类并重写 run() 方法来创建自己的Java线程类。然后通过创建该类的对象并执行 start() 方法来执行 run() 方法。1234567891011121314151617181920212223242526package com.journaldev.threads; public class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { System.out.println("MyThread - START "+Thread.currentThread().getName()); try { Thread.sleep(1000); //Get database connection, delete unused data from DB doDBProcessing(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("MyThread - END "+Thread.currentThread().getName()); } private void doDBProcessing() throws InterruptedException { Thread.sleep(5000); } } 测试测试代码1234567891011121314151617181920package com.journaldev.threads; public class ThreadRunExample { public static void main(String[] args){ Thread t1 = new Thread(new HeavyWorkRunnable(), "t1"); Thread t2 = new Thread(new HeavyWorkRunnable(), "t2"); System.out.println("Starting Runnable threads"); t1.start(); t2.start(); System.out.println("Runnable Threads has been started"); Thread t3 = new MyThread("t3"); Thread t4 = new MyThread("t4"); System.out.println("Starting MyThreads"); t3.start(); t4.start(); System.out.println("MyThreads has been started"); } } 运行结果 Starting Runnable threads Runnable Threads has been started Doing heavy processing - START t1 Doing heavy processing - START t2 Starting MyThreads MyThread - START Thread-0 MyThreads has been started MyThread - START Thread-1 Doing heavy processing - END t2 MyThread - END Thread-1 MyThread - END Thread-0 Doing heavy processing - END t1 线程优先级一旦我们启动任何线程，它的执行取决于操作系统时间分片的实现，我们无法控制它们的执行。不过，我们可以设置线程优先级，但即使如此，也不能保证优先级更高的线程会先执行。 多次运行上述程序，您将看到没有线程开始和结束的模式。Runnable vs Thread由于Java是单根继承的，所有一般推荐使用实现 Runnable 接口的方式；如果你的类只作为线程类也可以直接继承Thread类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Thread</tag>
      </tags>
  </entry>
</search>
